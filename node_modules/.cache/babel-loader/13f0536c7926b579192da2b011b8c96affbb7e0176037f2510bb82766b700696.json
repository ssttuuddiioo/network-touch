{"ast":null,"code":"// Calculate responsive dimensions based on window size\nexport const getResponsiveDimensions = () => {\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n\n  // Device dimensions - full viewport\n  const deviceWidth = windowWidth;\n  const deviceHeight = windowHeight;\n\n  // Detect portrait mode (mobile devices typically)\n  const isPortrait = windowHeight > windowWidth;\n\n  // Scale icon size based on device size with better portrait support\n  let baseIconSize, minIconSize;\n  if (isPortrait) {\n    // Portrait mode: make circles much larger and more touch-friendly (2x size)\n    baseIconSize = 240; // 2x larger base size for portrait (was 120)\n    minIconSize = 200; // 2x higher minimum for touch interaction (was 100)\n    // Scale based on width for portrait, but with a more generous multiplier\n    const scaleFactor = Math.min(windowWidth / 400, 1.5); // Cap scaling but be more generous\n    baseIconSize = baseIconSize * scaleFactor;\n  } else {\n    // Landscape mode: also increase for better visibility (2x size)\n    baseIconSize = 360; // 2x larger (was 180)\n    minIconSize = 180; // 2x larger minimum (was 90)\n  }\n  const iconSize = Math.max(baseIconSize * (deviceWidth / 1200), minIconSize);\n  const iconMargin = iconSize * 0.08; // Much tighter spacing for honeycomb effect\n\n  // Create a large grid for infinite scrolling effect\n  const cellWidth = iconSize + iconMargin;\n  const cellHeight = iconSize + iconMargin;\n\n  // Calculate how many icons fit in viewport (visible area) - adjust for larger circles\n  const buffer = isPortrait ? 2 : 3; // Smaller buffer since circles are much larger\n  const visibleCols = Math.ceil(deviceWidth / cellWidth) + buffer;\n  const visibleRows = Math.ceil(deviceHeight / cellHeight) + buffer;\n\n  // Create a grid for infinite scrolling - smaller multiplier since circles are larger\n  const multiplier = isPortrait ? 2.5 : 3; // Smaller grid since each circle takes more space\n  const totalCols = Math.ceil(visibleCols * multiplier);\n  const totalRows = Math.ceil(visibleRows * multiplier);\n\n  // Calculate total circles\n  const totalCircles = totalRows * totalCols;\n  return {\n    device: {\n      width: deviceWidth,\n      height: deviceHeight\n    },\n    icon: {\n      size: iconSize,\n      margin: iconMargin\n    },\n    grid: {\n      rows: totalRows,\n      cols: totalCols,\n      visibleRows,\n      visibleCols,\n      cellWidth,\n      cellHeight,\n      totalCircles\n    }\n  };\n};\n\n// Default fallback values\nexport const icon = {\n  margin: 12,\n  size: 60\n};\nexport const device = {\n  width: 800,\n  height: 600\n};","map":{"version":3,"names":["getResponsiveDimensions","windowWidth","window","innerWidth","windowHeight","innerHeight","deviceWidth","deviceHeight","isPortrait","baseIconSize","minIconSize","scaleFactor","Math","min","iconSize","max","iconMargin","cellWidth","cellHeight","buffer","visibleCols","ceil","visibleRows","multiplier","totalCols","totalRows","totalCircles","device","width","height","icon","size","margin","grid","rows","cols"],"sources":["/Users/pablognecco/Dropbox (Personal)/Studio/Cursor/network/src/AppleWatchDock/settings.js"],"sourcesContent":["// Calculate responsive dimensions based on window size\nexport const getResponsiveDimensions = () => {\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n  \n  // Device dimensions - full viewport\n  const deviceWidth = windowWidth;\n  const deviceHeight = windowHeight;\n  \n  // Detect portrait mode (mobile devices typically)\n  const isPortrait = windowHeight > windowWidth;\n  \n  // Scale icon size based on device size with better portrait support\n  let baseIconSize, minIconSize;\n  \n  if (isPortrait) {\n    // Portrait mode: make circles much larger and more touch-friendly (2x size)\n    baseIconSize = 240; // 2x larger base size for portrait (was 120)\n    minIconSize = 200; // 2x higher minimum for touch interaction (was 100)\n    // Scale based on width for portrait, but with a more generous multiplier\n    const scaleFactor = Math.min(windowWidth / 400, 1.5); // Cap scaling but be more generous\n    baseIconSize = baseIconSize * scaleFactor;\n  } else {\n    // Landscape mode: also increase for better visibility (2x size)\n    baseIconSize = 360; // 2x larger (was 180)\n    minIconSize = 180; // 2x larger minimum (was 90)\n  }\n  \n  const iconSize = Math.max(baseIconSize * (deviceWidth / 1200), minIconSize);\n  const iconMargin = iconSize * 0.08; // Much tighter spacing for honeycomb effect\n  \n  // Create a large grid for infinite scrolling effect\n  const cellWidth = iconSize + iconMargin;\n  const cellHeight = iconSize + iconMargin;\n  \n  // Calculate how many icons fit in viewport (visible area) - adjust for larger circles\n  const buffer = isPortrait ? 2 : 3; // Smaller buffer since circles are much larger\n  const visibleCols = Math.ceil(deviceWidth / cellWidth) + buffer;\n  const visibleRows = Math.ceil(deviceHeight / cellHeight) + buffer;\n  \n  // Create a grid for infinite scrolling - smaller multiplier since circles are larger\n  const multiplier = isPortrait ? 2.5 : 3; // Smaller grid since each circle takes more space\n  const totalCols = Math.ceil(visibleCols * multiplier);\n  const totalRows = Math.ceil(visibleRows * multiplier);\n  \n  // Calculate total circles\n  const totalCircles = totalRows * totalCols;\n  \n  return {\n    device: {\n      width: deviceWidth,\n      height: deviceHeight\n    },\n    icon: {\n      size: iconSize,\n      margin: iconMargin\n    },\n    grid: {\n      rows: totalRows,\n      cols: totalCols,\n      visibleRows,\n      visibleCols,\n      cellWidth,\n      cellHeight,\n      totalCircles\n    }\n  };\n};\n\n// Default fallback values\nexport const icon = {\n  margin: 12,\n  size: 60\n};\n\nexport const device = {\n  width: 800,\n  height: 600\n};\n"],"mappings":"AAAA;AACA,OAAO,MAAMA,uBAAuB,GAAGA,CAAA,KAAM;EAC3C,MAAMC,WAAW,GAAGC,MAAM,CAACC,UAAU;EACrC,MAAMC,YAAY,GAAGF,MAAM,CAACG,WAAW;;EAEvC;EACA,MAAMC,WAAW,GAAGL,WAAW;EAC/B,MAAMM,YAAY,GAAGH,YAAY;;EAEjC;EACA,MAAMI,UAAU,GAAGJ,YAAY,GAAGH,WAAW;;EAE7C;EACA,IAAIQ,YAAY,EAAEC,WAAW;EAE7B,IAAIF,UAAU,EAAE;IACd;IACAC,YAAY,GAAG,GAAG,CAAC,CAAC;IACpBC,WAAW,GAAG,GAAG,CAAC,CAAC;IACnB;IACA,MAAMC,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACZ,WAAW,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IACtDQ,YAAY,GAAGA,YAAY,GAAGE,WAAW;EAC3C,CAAC,MAAM;IACL;IACAF,YAAY,GAAG,GAAG,CAAC,CAAC;IACpBC,WAAW,GAAG,GAAG,CAAC,CAAC;EACrB;EAEA,MAAMI,QAAQ,GAAGF,IAAI,CAACG,GAAG,CAACN,YAAY,IAAIH,WAAW,GAAG,IAAI,CAAC,EAAEI,WAAW,CAAC;EAC3E,MAAMM,UAAU,GAAGF,QAAQ,GAAG,IAAI,CAAC,CAAC;;EAEpC;EACA,MAAMG,SAAS,GAAGH,QAAQ,GAAGE,UAAU;EACvC,MAAME,UAAU,GAAGJ,QAAQ,GAAGE,UAAU;;EAExC;EACA,MAAMG,MAAM,GAAGX,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EACnC,MAAMY,WAAW,GAAGR,IAAI,CAACS,IAAI,CAACf,WAAW,GAAGW,SAAS,CAAC,GAAGE,MAAM;EAC/D,MAAMG,WAAW,GAAGV,IAAI,CAACS,IAAI,CAACd,YAAY,GAAGW,UAAU,CAAC,GAAGC,MAAM;;EAEjE;EACA,MAAMI,UAAU,GAAGf,UAAU,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC;EACzC,MAAMgB,SAAS,GAAGZ,IAAI,CAACS,IAAI,CAACD,WAAW,GAAGG,UAAU,CAAC;EACrD,MAAME,SAAS,GAAGb,IAAI,CAACS,IAAI,CAACC,WAAW,GAAGC,UAAU,CAAC;;EAErD;EACA,MAAMG,YAAY,GAAGD,SAAS,GAAGD,SAAS;EAE1C,OAAO;IACLG,MAAM,EAAE;MACNC,KAAK,EAAEtB,WAAW;MAClBuB,MAAM,EAAEtB;IACV,CAAC;IACDuB,IAAI,EAAE;MACJC,IAAI,EAAEjB,QAAQ;MACdkB,MAAM,EAAEhB;IACV,CAAC;IACDiB,IAAI,EAAE;MACJC,IAAI,EAAET,SAAS;MACfU,IAAI,EAAEX,SAAS;MACfF,WAAW;MACXF,WAAW;MACXH,SAAS;MACTC,UAAU;MACVQ;IACF;EACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMI,IAAI,GAAG;EAClBE,MAAM,EAAE,EAAE;EACVD,IAAI,EAAE;AACR,CAAC;AAED,OAAO,MAAMJ,MAAM,GAAG;EACpBC,KAAK,EAAE,GAAG;EACVC,MAAM,EAAE;AACV,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}