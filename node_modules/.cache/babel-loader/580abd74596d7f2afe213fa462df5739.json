{"ast":null,"code":"import _asyncToGenerator from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"/Users/pablognecco/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nimport { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport var internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport var LockAcquireTimeoutError = /*#__PURE__*/function (_Error) {\n  _inherits(LockAcquireTimeoutError, _Error);\n  function LockAcquireTimeoutError(message) {\n    var _this;\n    _classCallCheck(this, LockAcquireTimeoutError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LockAcquireTimeoutError).call(this, message));\n    _this.isAcquireTimeout = true;\n    return _this;\n  }\n  return LockAcquireTimeoutError;\n}(_wrapNativeSuper(Error));\nexport var NavigatorLockAcquireTimeoutError = /*#__PURE__*/function (_LockAcquireTimeoutEr) {\n  _inherits(NavigatorLockAcquireTimeoutError, _LockAcquireTimeoutEr);\n  function NavigatorLockAcquireTimeoutError() {\n    _classCallCheck(this, NavigatorLockAcquireTimeoutError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(NavigatorLockAcquireTimeoutError).apply(this, arguments));\n  }\n  return NavigatorLockAcquireTimeoutError;\n}(LockAcquireTimeoutError);\nexport var ProcessLockAcquireTimeoutError = /*#__PURE__*/function (_LockAcquireTimeoutEr2) {\n  _inherits(ProcessLockAcquireTimeoutError, _LockAcquireTimeoutEr2);\n  function ProcessLockAcquireTimeoutError() {\n    _classCallCheck(this, ProcessLockAcquireTimeoutError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ProcessLockAcquireTimeoutError).apply(this, arguments));\n  }\n  return ProcessLockAcquireTimeoutError;\n}(LockAcquireTimeoutError);\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport function navigatorLock(_x, _x2, _x3) {\n  return _navigatorLock.apply(this, arguments);\n}\nfunction _navigatorLock() {\n  _navigatorLock = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(name, acquireTimeout, fn) {\n    var abortController;\n    return _regenerator().w(function (_context2) {\n      while (1) switch (_context2.n) {\n        case 0:\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n          }\n          abortController = new globalThis.AbortController();\n          if (acquireTimeout > 0) {\n            setTimeout(function () {\n              abortController.abort();\n              if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n              }\n            }, acquireTimeout);\n          }\n          // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n          // Wrapping navigator.locks.request() with a plain Promise is done as some\n          // libraries like zone.js patch the Promise object to track the execution\n          // context. However, it appears that most browsers use an internal promise\n          // implementation when using the navigator.locks.request() API causing them\n          // to lose context and emit confusing log messages or break certain features.\n          // This wrapping is believed to help zone.js track the execution context\n          // better.\n          _context2.n = 1;\n          return Promise.resolve().then(function () {\n            return globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n              mode: 'exclusive',\n              ifAvailable: true\n            } : {\n              mode: 'exclusive',\n              signal: abortController.signal\n            }, /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(lock) {\n                var result, _t;\n                return _regenerator().w(function (_context) {\n                  while (1) switch (_context.p = _context.n) {\n                    case 0:\n                      if (!lock) {\n                        _context.n = 5;\n                        break;\n                      }\n                      if (internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n                      }\n                      _context.p = 1;\n                      _context.n = 2;\n                      return fn();\n                    case 2:\n                      return _context.a(2, _context.v);\n                    case 3:\n                      _context.p = 3;\n                      if (internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                      }\n                      return _context.f(3);\n                    case 4:\n                      _context.n = 12;\n                      break;\n                    case 5:\n                      if (!(acquireTimeout === 0)) {\n                        _context.n = 6;\n                        break;\n                      }\n                      if (internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                      }\n                      throw new NavigatorLockAcquireTimeoutError(\"Acquiring an exclusive Navigator LockManager lock \\\"\".concat(name, \"\\\" immediately failed\"));\n                    case 6:\n                      if (!internals.debug) {\n                        _context.n = 10;\n                        break;\n                      }\n                      _context.p = 7;\n                      _context.n = 8;\n                      return globalThis.navigator.locks.query();\n                    case 8:\n                      result = _context.v;\n                      console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                      _context.n = 10;\n                      break;\n                    case 9:\n                      _context.p = 9;\n                      _t = _context.v;\n                      console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', _t);\n                    case 10:\n                      // Browser is not following the Navigator LockManager spec, it\n                      // returned a null lock when we didn't use ifAvailable. So we can\n                      // pretend the lock is acquired in the name of backward compatibility\n                      // and user experience and just run the function.\n                      console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                      _context.n = 11;\n                      return fn();\n                    case 11:\n                      return _context.a(2, _context.v);\n                    case 12:\n                      return _context.a(2);\n                  }\n                }, _callee, null, [[7, 9], [1,, 3, 4]]);\n              }));\n              return function (_x7) {\n                return _ref.apply(this, arguments);\n              };\n            }());\n          });\n        case 1:\n          return _context2.a(2, _context2.v);\n      }\n    }, _callee2);\n  }));\n  return _navigatorLock.apply(this, arguments);\n}\nvar PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport function processLock(_x4, _x5, _x6) {\n  return _processLock.apply(this, arguments);\n}\nfunction _processLock() {\n  _processLock = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(name, acquireTimeout, fn) {\n    var _a, previousOperation, currentOperation;\n    return _regenerator().w(function (_context5) {\n      while (1) switch (_context5.n) {\n        case 0:\n          previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n          currentOperation = Promise.race([previousOperation.catch(function () {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n          }), acquireTimeout >= 0 ? new Promise(function (_, reject) {\n            setTimeout(function () {\n              reject(new ProcessLockAcquireTimeoutError(\"Acquring process lock with name \\\"\".concat(name, \"\\\" timed out\")));\n            }, acquireTimeout);\n          }) : null].filter(function (x) {\n            return x;\n          })).catch(function (e) {\n            if (e && e.isAcquireTimeout) {\n              throw e;\n            }\n            return null;\n          }).then(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n            return _regenerator().w(function (_context3) {\n              while (1) switch (_context3.n) {\n                case 0:\n                  _context3.n = 1;\n                  return fn();\n                case 1:\n                  return _context3.a(2, _context3.v);\n              }\n            }, _callee3);\n          })));\n          PROCESS_LOCKS[name] = currentOperation.catch(/*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(e) {\n              return _regenerator().w(function (_context4) {\n                while (1) switch (_context4.n) {\n                  case 0:\n                    if (!(e && e.isAcquireTimeout)) {\n                      _context4.n = 2;\n                      break;\n                    }\n                    _context4.n = 1;\n                    return previousOperation;\n                  case 1:\n                    return _context4.a(2, null);\n                  case 2:\n                    throw e;\n                  case 3:\n                    return _context4.a(2);\n                }\n              }, _callee4);\n            }));\n            return function (_x8) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n          // finally wait for the current operation to finish successfully, with an\n          // error or with an acquire timeout error\n          _context5.n = 1;\n          return currentOperation;\n        case 1:\n          return _context5.a(2, _context5.v);\n      }\n    }, _callee5);\n  }));\n  return _processLock.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}