{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo, useRef } from \"react\";\nimport { transform } from \"framer-motion\";\n\n// Transform the provided x, y and scale motion values based on changes\n// in the provided planeX and planeY motion values with 45+ scaling layers\nexport function useIconTransform(_ref) {\n  _s();\n  let {\n    x,\n    y,\n    scale,\n    planeX,\n    planeY,\n    xOffset,\n    yOffset,\n    dimensions\n  } = _ref;\n  // Keep track of our calculated x and y scales\n  const xScale = useRef(1);\n  const yScale = useRef(1);\n\n  // Create responsive screen ranges based on current dimensions\n  const {\n    device\n  } = dimensions;\n\n  // Create multiple concentric zones for 45+ layers of scaling\n  // Account for FilterBar offset from CSS (.device has top: 60px/80px)\n  const filterBarOffset = window.innerWidth <= 768 ? 80 : 60; // Mobile vs desktop\n  const centerX = device.width / 2;\n  const centerY = (device.height - filterBarOffset) / 2; // Center of the visible content area\n  const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY) * 0.85; // Smaller effective radius for more responsive scaling\n\n  // Function to calculate distance-based scale with center being largest\n  const calculateDistanceScale = (screenX, screenY) => {\n    const distanceFromCenter = Math.sqrt(Math.pow(screenX - centerX, 2) + Math.pow(screenY - centerY, 2));\n\n    // Create 80 distinct scaling layers for more granular responsiveness\n    const normalizedDistance = Math.min(distanceFromCenter / maxDistance, 1);\n    const layer = Math.floor(normalizedDistance * 80); // 80 layers for smoother transitions\n\n    // More dramatic scaling with steeper curve for better reactivity\n    const scaleCurve = Math.pow(1 - normalizedDistance, 1.5); // Exponential curve\n    const layerScale = 0.3 + scaleCurve * 1.0; // Scale from 1.3 to 0.3\n\n    // Enhanced smooth interpolation for ultra-responsive scaling\n    const layerProgress = normalizedDistance * 80 - layer;\n    const nextScaleCurve = Math.pow(1 - Math.min((layer + 1) / 80, 1), 1.5);\n    const nextLayerScale = 0.3 + nextScaleCurve * 1.0;\n\n    // Add micro-interpolation for buttery smooth scaling\n    const finalScale = layerScale + (nextLayerScale - layerScale) * layerProgress;\n    return Math.max(finalScale, 0.25);\n  };\n\n  // More responsive screen ranges for immediate feedback\n  const createScreenRange = axis => [-150,\n  // Tighter range for more immediate scaling response\n  150, device[axis] - 150, device[axis] + 150];\n  const offsetRange = [80, 0, 0, -80]; // More responsive offsets\n\n  const xRange = createScreenRange(\"width\");\n  const yRange = createScreenRange(\"height\");\n  const mapScreenToXOffset = transform(xRange, offsetRange);\n  const mapScreenToYOffset = transform(yRange, offsetRange);\n\n  // Store current plane positions for distance calculation\n  const currentPlaneX = useRef(0);\n  const currentPlaneY = useRef(0);\n  useMemo(() => {\n    // Transform x and scale based on planeX\n    const transformX = v => {\n      currentPlaneX.current = v;\n      // Calculate circle position relative to the content area center\n      // xOffset and yOffset are the circle's position in the grid\n      // v is the current plane drag offset\n      const contentX = xOffset + v; // Circle's X position in content area\n      const contentY = yOffset + currentPlaneY.current; // Circle's Y position in content area\n\n      // Calculate distance from content area center\n      xScale.current = calculateDistanceScale(contentX, contentY);\n      const newScale = Math.min(xScale.current, yScale.current);\n      scale.set(newScale);\n      x.set(mapScreenToXOffset(contentX));\n    };\n    return planeX.onRenderRequest(transformX);\n  }, [planeX, scale, x, xOffset, yOffset, centerX, centerY, maxDistance]);\n  useMemo(() => {\n    // Transform y and scale based on planeY\n    const transformY = v => {\n      currentPlaneY.current = v;\n      // Calculate circle position relative to the content area center\n      const contentX = xOffset + currentPlaneX.current; // Circle's X position in content area\n      const contentY = yOffset + v; // Circle's Y position in content area\n\n      // Calculate distance from content area center\n      yScale.current = calculateDistanceScale(contentX, contentY);\n      const newScale = Math.min(xScale.current, yScale.current);\n      scale.set(newScale);\n      y.set(mapScreenToYOffset(contentY));\n    };\n    return planeY.onRenderRequest(transformY);\n  }, [planeY, scale, y, xOffset, yOffset, centerX, centerY, maxDistance]);\n}\n_s(useIconTransform, \"24VjNnT251ybTGVoEtxYYwjyysc=\");","map":{"version":3,"names":["useMemo","useRef","transform","useIconTransform","_ref","_s","x","y","scale","planeX","planeY","xOffset","yOffset","dimensions","xScale","yScale","device","filterBarOffset","window","innerWidth","centerX","width","centerY","height","maxDistance","Math","sqrt","calculateDistanceScale","screenX","screenY","distanceFromCenter","pow","normalizedDistance","min","layer","floor","scaleCurve","layerScale","layerProgress","nextScaleCurve","nextLayerScale","finalScale","max","createScreenRange","axis","offsetRange","xRange","yRange","mapScreenToXOffset","mapScreenToYOffset","currentPlaneX","currentPlaneY","transformX","v","current","contentX","contentY","newScale","set","onRenderRequest","transformY"],"sources":["/Users/pablognecco/Dropbox (Personal)/Studio/Civic/pitch/framer-motion-bubbles/src/AppleWatchDock/use-icon-transform.js"],"sourcesContent":["import { useMemo, useRef } from \"react\";\nimport { transform } from \"framer-motion\";\n\n// Transform the provided x, y and scale motion values based on changes\n// in the provided planeX and planeY motion values with 45+ scaling layers\nexport function useIconTransform({\n  x,\n  y,\n  scale,\n  planeX,\n  planeY,\n  xOffset,\n  yOffset,\n  dimensions\n}) {\n  // Keep track of our calculated x and y scales\n  const xScale = useRef(1);\n  const yScale = useRef(1);\n\n  // Create responsive screen ranges based on current dimensions\n  const { device } = dimensions;\n  \n  // Create multiple concentric zones for 45+ layers of scaling\n  // Account for FilterBar offset from CSS (.device has top: 60px/80px)\n  const filterBarOffset = window.innerWidth <= 768 ? 80 : 60; // Mobile vs desktop\n  const centerX = device.width / 2;\n  const centerY = (device.height - filterBarOffset) / 2; // Center of the visible content area\n  const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY) * 0.85; // Smaller effective radius for more responsive scaling\n  \n  // Function to calculate distance-based scale with center being largest\n  const calculateDistanceScale = (screenX, screenY) => {\n    const distanceFromCenter = Math.sqrt(\n      Math.pow(screenX - centerX, 2) + Math.pow(screenY - centerY, 2)\n    );\n    \n    // Create 80 distinct scaling layers for more granular responsiveness\n    const normalizedDistance = Math.min(distanceFromCenter / maxDistance, 1);\n    const layer = Math.floor(normalizedDistance * 80); // 80 layers for smoother transitions\n    \n    // More dramatic scaling with steeper curve for better reactivity\n    const scaleCurve = Math.pow(1 - normalizedDistance, 1.5); // Exponential curve\n    const layerScale = 0.3 + scaleCurve * 1.0; // Scale from 1.3 to 0.3\n    \n    // Enhanced smooth interpolation for ultra-responsive scaling\n    const layerProgress = (normalizedDistance * 80) - layer;\n    const nextScaleCurve = Math.pow(1 - Math.min((layer + 1) / 80, 1), 1.5);\n    const nextLayerScale = 0.3 + nextScaleCurve * 1.0;\n    \n    // Add micro-interpolation for buttery smooth scaling\n    const finalScale = layerScale + (nextLayerScale - layerScale) * layerProgress;\n    return Math.max(finalScale, 0.25);\n  };\n  \n  // More responsive screen ranges for immediate feedback\n  const createScreenRange = (axis) => [\n    -150, // Tighter range for more immediate scaling response\n    150,\n    device[axis] - 150,\n    device[axis] + 150\n  ];\n  \n  const offsetRange = [80, 0, 0, -80]; // More responsive offsets\n  \n  const xRange = createScreenRange(\"width\");\n  const yRange = createScreenRange(\"height\");\n  \n  const mapScreenToXOffset = transform(xRange, offsetRange);\n  const mapScreenToYOffset = transform(yRange, offsetRange);\n\n  // Store current plane positions for distance calculation\n  const currentPlaneX = useRef(0);\n  const currentPlaneY = useRef(0);\n\n  useMemo(() => {\n    // Transform x and scale based on planeX\n    const transformX = v => {\n      currentPlaneX.current = v;\n      // Calculate circle position relative to the content area center\n      // xOffset and yOffset are the circle's position in the grid\n      // v is the current plane drag offset\n      const contentX = xOffset + v; // Circle's X position in content area\n      const contentY = yOffset + currentPlaneY.current; // Circle's Y position in content area\n      \n      // Calculate distance from content area center\n      xScale.current = calculateDistanceScale(contentX, contentY);\n      const newScale = Math.min(xScale.current, yScale.current);\n\n      scale.set(newScale);\n      x.set(mapScreenToXOffset(contentX));\n    };\n\n    return planeX.onRenderRequest(transformX);\n  }, [planeX, scale, x, xOffset, yOffset, centerX, centerY, maxDistance]);\n\n  useMemo(() => {\n    // Transform y and scale based on planeY\n    const transformY = v => {\n      currentPlaneY.current = v;\n      // Calculate circle position relative to the content area center\n      const contentX = xOffset + currentPlaneX.current; // Circle's X position in content area\n      const contentY = yOffset + v; // Circle's Y position in content area\n      \n      // Calculate distance from content area center\n      yScale.current = calculateDistanceScale(contentX, contentY);\n      const newScale = Math.min(xScale.current, yScale.current);\n      \n      scale.set(newScale);\n      y.set(mapScreenToYOffset(contentY));\n    };\n\n    return planeY.onRenderRequest(transformY);\n  }, [planeY, scale, y, xOffset, yOffset, centerX, centerY, maxDistance]);\n}\n"],"mappings":";AAAA,SAASA,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,SAASC,SAAS,QAAQ,eAAe;;AAEzC;AACA;AACA,OAAO,SAASC,gBAAgBA,CAAAC,IAAA,EAS7B;EAAAC,EAAA;EAAA,IAT8B;IAC/BC,CAAC;IACDC,CAAC;IACDC,KAAK;IACLC,MAAM;IACNC,MAAM;IACNC,OAAO;IACPC,OAAO;IACPC;EACF,CAAC,GAAAT,IAAA;EACC;EACA,MAAMU,MAAM,GAAGb,MAAM,CAAC,CAAC,CAAC;EACxB,MAAMc,MAAM,GAAGd,MAAM,CAAC,CAAC,CAAC;;EAExB;EACA,MAAM;IAAEe;EAAO,CAAC,GAAGH,UAAU;;EAE7B;EACA;EACA,MAAMI,eAAe,GAAGC,MAAM,CAACC,UAAU,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;EAC5D,MAAMC,OAAO,GAAGJ,MAAM,CAACK,KAAK,GAAG,CAAC;EAChC,MAAMC,OAAO,GAAG,CAACN,MAAM,CAACO,MAAM,GAAGN,eAAe,IAAI,CAAC,CAAC,CAAC;EACvD,MAAMO,WAAW,GAAGC,IAAI,CAACC,IAAI,CAACN,OAAO,GAAGA,OAAO,GAAGE,OAAO,GAAGA,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC;;EAE7E;EACA,MAAMK,sBAAsB,GAAGA,CAACC,OAAO,EAAEC,OAAO,KAAK;IACnD,MAAMC,kBAAkB,GAAGL,IAAI,CAACC,IAAI,CAClCD,IAAI,CAACM,GAAG,CAACH,OAAO,GAAGR,OAAO,EAAE,CAAC,CAAC,GAAGK,IAAI,CAACM,GAAG,CAACF,OAAO,GAAGP,OAAO,EAAE,CAAC,CAChE,CAAC;;IAED;IACA,MAAMU,kBAAkB,GAAGP,IAAI,CAACQ,GAAG,CAACH,kBAAkB,GAAGN,WAAW,EAAE,CAAC,CAAC;IACxE,MAAMU,KAAK,GAAGT,IAAI,CAACU,KAAK,CAACH,kBAAkB,GAAG,EAAE,CAAC,CAAC,CAAC;;IAEnD;IACA,MAAMI,UAAU,GAAGX,IAAI,CAACM,GAAG,CAAC,CAAC,GAAGC,kBAAkB,EAAE,GAAG,CAAC,CAAC,CAAC;IAC1D,MAAMK,UAAU,GAAG,GAAG,GAAGD,UAAU,GAAG,GAAG,CAAC,CAAC;;IAE3C;IACA,MAAME,aAAa,GAAIN,kBAAkB,GAAG,EAAE,GAAIE,KAAK;IACvD,MAAMK,cAAc,GAAGd,IAAI,CAACM,GAAG,CAAC,CAAC,GAAGN,IAAI,CAACQ,GAAG,CAAC,CAACC,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC;IACvE,MAAMM,cAAc,GAAG,GAAG,GAAGD,cAAc,GAAG,GAAG;;IAEjD;IACA,MAAME,UAAU,GAAGJ,UAAU,GAAG,CAACG,cAAc,GAAGH,UAAU,IAAIC,aAAa;IAC7E,OAAOb,IAAI,CAACiB,GAAG,CAACD,UAAU,EAAE,IAAI,CAAC;EACnC,CAAC;;EAED;EACA,MAAME,iBAAiB,GAAIC,IAAI,IAAK,CAClC,CAAC,GAAG;EAAE;EACN,GAAG,EACH5B,MAAM,CAAC4B,IAAI,CAAC,GAAG,GAAG,EAClB5B,MAAM,CAAC4B,IAAI,CAAC,GAAG,GAAG,CACnB;EAED,MAAMC,WAAW,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;EAErC,MAAMC,MAAM,GAAGH,iBAAiB,CAAC,OAAO,CAAC;EACzC,MAAMI,MAAM,GAAGJ,iBAAiB,CAAC,QAAQ,CAAC;EAE1C,MAAMK,kBAAkB,GAAG9C,SAAS,CAAC4C,MAAM,EAAED,WAAW,CAAC;EACzD,MAAMI,kBAAkB,GAAG/C,SAAS,CAAC6C,MAAM,EAAEF,WAAW,CAAC;;EAEzD;EACA,MAAMK,aAAa,GAAGjD,MAAM,CAAC,CAAC,CAAC;EAC/B,MAAMkD,aAAa,GAAGlD,MAAM,CAAC,CAAC,CAAC;EAE/BD,OAAO,CAAC,MAAM;IACZ;IACA,MAAMoD,UAAU,GAAGC,CAAC,IAAI;MACtBH,aAAa,CAACI,OAAO,GAAGD,CAAC;MACzB;MACA;MACA;MACA,MAAME,QAAQ,GAAG5C,OAAO,GAAG0C,CAAC,CAAC,CAAC;MAC9B,MAAMG,QAAQ,GAAG5C,OAAO,GAAGuC,aAAa,CAACG,OAAO,CAAC,CAAC;;MAElD;MACAxC,MAAM,CAACwC,OAAO,GAAG3B,sBAAsB,CAAC4B,QAAQ,EAAEC,QAAQ,CAAC;MAC3D,MAAMC,QAAQ,GAAGhC,IAAI,CAACQ,GAAG,CAACnB,MAAM,CAACwC,OAAO,EAAEvC,MAAM,CAACuC,OAAO,CAAC;MAEzD9C,KAAK,CAACkD,GAAG,CAACD,QAAQ,CAAC;MACnBnD,CAAC,CAACoD,GAAG,CAACV,kBAAkB,CAACO,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED,OAAO9C,MAAM,CAACkD,eAAe,CAACP,UAAU,CAAC;EAC3C,CAAC,EAAE,CAAC3C,MAAM,EAAED,KAAK,EAAEF,CAAC,EAAEK,OAAO,EAAEC,OAAO,EAAEQ,OAAO,EAAEE,OAAO,EAAEE,WAAW,CAAC,CAAC;EAEvExB,OAAO,CAAC,MAAM;IACZ;IACA,MAAM4D,UAAU,GAAGP,CAAC,IAAI;MACtBF,aAAa,CAACG,OAAO,GAAGD,CAAC;MACzB;MACA,MAAME,QAAQ,GAAG5C,OAAO,GAAGuC,aAAa,CAACI,OAAO,CAAC,CAAC;MAClD,MAAME,QAAQ,GAAG5C,OAAO,GAAGyC,CAAC,CAAC,CAAC;;MAE9B;MACAtC,MAAM,CAACuC,OAAO,GAAG3B,sBAAsB,CAAC4B,QAAQ,EAAEC,QAAQ,CAAC;MAC3D,MAAMC,QAAQ,GAAGhC,IAAI,CAACQ,GAAG,CAACnB,MAAM,CAACwC,OAAO,EAAEvC,MAAM,CAACuC,OAAO,CAAC;MAEzD9C,KAAK,CAACkD,GAAG,CAACD,QAAQ,CAAC;MACnBlD,CAAC,CAACmD,GAAG,CAACT,kBAAkB,CAACO,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED,OAAO9C,MAAM,CAACiD,eAAe,CAACC,UAAU,CAAC;EAC3C,CAAC,EAAE,CAAClD,MAAM,EAAEF,KAAK,EAAED,CAAC,EAAEI,OAAO,EAAEC,OAAO,EAAEQ,OAAO,EAAEE,OAAO,EAAEE,WAAW,CAAC,CAAC;AACzE;AAACnB,EAAA,CA3GeF,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}