{"ast":null,"code":"// Utility to parse bulk company text into structured data\nexport const parseBulkCompanyText = text => {\n  if (!text || typeof text !== 'string') {\n    return {};\n  }\n  const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n  const company = {};\n\n  // Extract company name (first line)\n  if (lines.length > 0) {\n    company.name = lines[0];\n  }\n\n  // Parse each section\n  let currentSection = null;\n  let collectingData = false;\n  let multilineValue = [];\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Check if this is a section header\n    if (isValidSectionHeader(line)) {\n      // Save previous section if we were collecting data\n      if (currentSection && multilineValue.length > 0) {\n        const value = multilineValue.join(' ').trim();\n        setCompanyField(company, currentSection, value);\n        multilineValue = [];\n      }\n      currentSection = line;\n      collectingData = true;\n      continue;\n    }\n\n    // If we're in a section and this looks like content, collect it\n    if (collectingData && currentSection) {\n      // Skip empty lines and apparent subsection headers\n      if (line && !isSubsectionHeader(line)) {\n        multilineValue.push(line);\n      }\n    }\n  }\n\n  // Handle the last section\n  if (currentSection && multilineValue.length > 0) {\n    const value = multilineValue.join(' ').trim();\n    setCompanyField(company, currentSection, value);\n  }\n  return company;\n};\n\n// Check if a line is a valid section header we care about\nconst isValidSectionHeader = line => {\n  const headers = ['Description', 'Funding Stage', 'Industry', 'Modifiers', 'Newlab Relationship', 'Membership Status', 'Newlab Location(s)', 'Newlab Location', 'Founded', 'Team Size', 'Employees', 'Location', 'Website', 'Learn More', 'Tagline'];\n  return headers.some(header => line.toLowerCase().includes(header.toLowerCase()) || line === header);\n};\n\n// Check if a line is a subsection header (like \"Startup Details\")\nconst isSubsectionHeader = line => {\n  const subsections = ['Startup Details', 'Company Details', 'About', 'Overview'];\n  return subsections.some(sub => line.toLowerCase().includes(sub.toLowerCase()));\n};\n\n// Map parsed sections to company object fields\nconst setCompanyField = (company, section, value) => {\n  const sectionLower = section.toLowerCase();\n  if (sectionLower.includes('description')) {\n    company.description = value;\n  } else if (sectionLower.includes('tagline')) {\n    company.tagline = value;\n  } else if (sectionLower.includes('funding')) {\n    company.funding = value;\n  } else if (sectionLower.includes('industry') || sectionLower.includes('industries')) {\n    // Split industries by common separators\n    company.industry = value.split(/[,\\n]/).map(item => item.trim()).filter(item => item.length > 0);\n  } else if (sectionLower.includes('modifier')) {\n    // Parse modifiers as tags\n    company.tags = value.split(/[,\\n]/).map(item => item.trim()).filter(item => item.length > 0);\n  } else if (sectionLower.includes('location')) {\n    company.location = value;\n  } else if (sectionLower.includes('founded')) {\n    company.founded = value;\n  } else if (sectionLower.includes('team') || sectionLower.includes('employee')) {\n    company.employees = value;\n  } else if (sectionLower.includes('website') || sectionLower.includes('learn more')) {\n    // Extract website URL if it's in a \"Go to...\" format\n    if (value.toLowerCase().includes('go to')) {\n      company.website = value; // Keep the full text for now\n    } else {\n      company.website = value;\n    }\n  } else if (sectionLower.includes('newlab relationship')) {\n    company.newlabRelationship = value;\n  } else if (sectionLower.includes('membership')) {\n    company.membershipStatus = value;\n  }\n};\n\n// Generate a sample of the expected format for users\nexport const getBulkImportSample = () => {\n  return \"Company Name Here\\nStartup Details\\nDescription\\nBrief description of what the company does and their main products or services.\\n\\nFunding Stage\\nEarly (Seed to A)\\n\\nIndustry\\nTechnology\\nManufacturing\\nLogistics\\n\\nModifiers\\nAI\\nRobotics\\nSustainability\\n\\nNewlab Relationship\\nPortfolio\\n\\nMembership Status\\nActive Member\\n\\nNewlab Location(s)\\nDetroit\\n\\nFounded\\n2020\\n\\nTeam Size\\n15-25\\n\\nLearn More\\nGo to Startup's Website\";\n};","map":{"version":3,"names":["parseBulkCompanyText","text","lines","split","map","line","trim","filter","length","company","name","currentSection","collectingData","multilineValue","i","isValidSectionHeader","value","join","setCompanyField","isSubsectionHeader","push","headers","some","header","toLowerCase","includes","subsections","sub","section","sectionLower","description","tagline","funding","industry","item","tags","location","founded","employees","website","newlabRelationship","membershipStatus","getBulkImportSample"],"sources":["/Users/pablognecco/Dropbox (Personal)/Studio/Cursor/network/src/utils/bulkParser.js"],"sourcesContent":["// Utility to parse bulk company text into structured data\nexport const parseBulkCompanyText = (text) => {\n  if (!text || typeof text !== 'string') {\n    return {};\n  }\n\n  const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n  const company = {};\n  \n  // Extract company name (first line)\n  if (lines.length > 0) {\n    company.name = lines[0];\n  }\n\n  // Parse each section\n  let currentSection = null;\n  let collectingData = false;\n  let multilineValue = [];\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    \n    // Check if this is a section header\n    if (isValidSectionHeader(line)) {\n      // Save previous section if we were collecting data\n      if (currentSection && multilineValue.length > 0) {\n        const value = multilineValue.join(' ').trim();\n        setCompanyField(company, currentSection, value);\n        multilineValue = [];\n      }\n      \n      currentSection = line;\n      collectingData = true;\n      continue;\n    }\n\n    // If we're in a section and this looks like content, collect it\n    if (collectingData && currentSection) {\n      // Skip empty lines and apparent subsection headers\n      if (line && !isSubsectionHeader(line)) {\n        multilineValue.push(line);\n      }\n    }\n  }\n\n  // Handle the last section\n  if (currentSection && multilineValue.length > 0) {\n    const value = multilineValue.join(' ').trim();\n    setCompanyField(company, currentSection, value);\n  }\n\n  return company;\n};\n\n// Check if a line is a valid section header we care about\nconst isValidSectionHeader = (line) => {\n  const headers = [\n    'Description',\n    'Funding Stage', \n    'Industry',\n    'Modifiers',\n    'Newlab Relationship',\n    'Membership Status',\n    'Newlab Location(s)',\n    'Newlab Location',\n    'Founded',\n    'Team Size',\n    'Employees',\n    'Location',\n    'Website',\n    'Learn More',\n    'Tagline'\n  ];\n  \n  return headers.some(header => \n    line.toLowerCase().includes(header.toLowerCase()) ||\n    line === header\n  );\n};\n\n// Check if a line is a subsection header (like \"Startup Details\")\nconst isSubsectionHeader = (line) => {\n  const subsections = [\n    'Startup Details',\n    'Company Details',\n    'About',\n    'Overview'\n  ];\n  \n  return subsections.some(sub => \n    line.toLowerCase().includes(sub.toLowerCase())\n  );\n};\n\n// Map parsed sections to company object fields\nconst setCompanyField = (company, section, value) => {\n  const sectionLower = section.toLowerCase();\n  \n  if (sectionLower.includes('description')) {\n    company.description = value;\n  } \n  else if (sectionLower.includes('tagline')) {\n    company.tagline = value;\n  }\n  else if (sectionLower.includes('funding')) {\n    company.funding = value;\n  }\n  else if (sectionLower.includes('industry') || sectionLower.includes('industries')) {\n    // Split industries by common separators\n    company.industry = value.split(/[,\\n]/)\n      .map(item => item.trim())\n      .filter(item => item.length > 0);\n  }\n  else if (sectionLower.includes('modifier')) {\n    // Parse modifiers as tags\n    company.tags = value.split(/[,\\n]/)\n      .map(item => item.trim())\n      .filter(item => item.length > 0);\n  }\n  else if (sectionLower.includes('location')) {\n    company.location = value;\n  }\n  else if (sectionLower.includes('founded')) {\n    company.founded = value;\n  }\n  else if (sectionLower.includes('team') || sectionLower.includes('employee')) {\n    company.employees = value;\n  }\n  else if (sectionLower.includes('website') || sectionLower.includes('learn more')) {\n    // Extract website URL if it's in a \"Go to...\" format\n    if (value.toLowerCase().includes('go to')) {\n      company.website = value; // Keep the full text for now\n    } else {\n      company.website = value;\n    }\n  }\n  else if (sectionLower.includes('newlab relationship')) {\n    company.newlabRelationship = value;\n  }\n  else if (sectionLower.includes('membership')) {\n    company.membershipStatus = value;\n  }\n};\n\n// Generate a sample of the expected format for users\nexport const getBulkImportSample = () => {\n  return `Company Name Here\nStartup Details\nDescription\nBrief description of what the company does and their main products or services.\n\nFunding Stage\nEarly (Seed to A)\n\nIndustry\nTechnology\nManufacturing\nLogistics\n\nModifiers\nAI\nRobotics\nSustainability\n\nNewlab Relationship\nPortfolio\n\nMembership Status\nActive Member\n\nNewlab Location(s)\nDetroit\n\nFounded\n2020\n\nTeam Size\n15-25\n\nLearn More\nGo to Startup's Website`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}